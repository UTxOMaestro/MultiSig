<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Summon Exit — Multisig Sign</title>
<!-- Railway deployment trigger -->
<style>
  :root{
    --primary:#4f46e5;
    --primary-hover:#4338ca;
    --success:#10b981;
    --error:#ef4444;
    --gray-50:#f9fafb;
    --gray-100:#f3f4f6;
    --gray-600:#4b5563;
    --gray-800:#1f2937;
  }
  body{font-family:system-ui,ui-sans-serif;max-width:720px;margin:24px auto;padding:0 16px;background:var(--gray-50);line-height:1.6;font-size:16px}
  section{background:white;padding:24px;border-radius:12px;box-shadow:0 1px 3px rgba(0,0,0,0.1);margin-bottom:20px}
  h1{color:var(--gray-800);font-weight:700}
  h3{color:var(--gray-800);font-weight:600;margin-top:0}
  button{padding:10px 16px;background:var(--primary);color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500;transition:all 0.2s ease;font-size:14px}
  button:hover:not(:disabled){background:var(--primary-hover);transform:translateY(-1px);box-shadow:0 4px 6px rgba(79,70,229,0.2)}
  button:disabled{background:var(--gray-600);cursor:not-allowed;opacity:0.5}
  button.warning{background:var(--error)}
  button.warning:hover:not(:disabled){background:#dc2626;box-shadow:0 4px 6px rgba(239,68,68,0.3)}
  input{width:100%;padding:10px;margin:6px 0 12px;border:2px solid var(--gray-100);border-radius:8px;font-size:14px;transition:border-color 0.2s}
  input:focus{outline:none;border-color:var(--primary)}
  pre{background:var(--gray-100);padding:12px;border-radius:8px;overflow:auto;max-height:200px}
  code{word-break:break-all}
  .row{display:flex;gap:8px;align-items:center}
  .row>input{flex:1}
  .muted{color:var(--gray-600)}
  .ok{color:var(--success)}
  .err{color:var(--error)}
  .mono{font-family:ui-monospace,Consolas,Monaco,Menlo,monospace}
  .small{font-size:14px}
  .badge{display:inline-block;padding:4px 12px;border-radius:12px;font-size:13px;font-weight:500}
  .badge.success{background:#d1fae5;color:#065f46}
  .badge.error{background:#fee2e2;color:#991b1b}
  .badge.info{background:#dbeafe;color:#1e40af}
  .badge.warning{background:#fef3c7;color:#92400e}
  .progress-bar{background:var(--gray-100);height:8px;border-radius:4px;overflow:hidden;margin:8px 0}
  .progress-fill{background:linear-gradient(90deg,var(--primary),var(--success));height:100%;transition:width 0.3s ease;border-radius:4px}
  hr{border:none;border-top:1px solid var(--gray-100);margin:20px 0}
  .collapsible{cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:6px;color:var(--primary);font-weight:500}
  .collapsible:hover{color:var(--primary-hover)}
  .collapsible::before{content:'▼';font-size:10px;transition:transform 0.2s}
  .collapsible.collapsed::before{transform:rotate(-90deg)}
  .collapse-content{max-height:400px;overflow:auto;transition:max-height 0.3s ease}
  .collapse-content.collapsed{max-height:0;overflow:hidden}
  .tx-preview{background:var(--gray-100);padding:12px;border-radius:8px;margin-top:8px;word-wrap:break-word;overflow-wrap:break-word}
  .tx-preview-label{font-weight:600;color:var(--gray-800);display:block;margin-top:8px}
  .tx-preview-label:first-child{margin-top:0}
  .tx-preview-value{display:block;margin-top:4px;font-size:13px;word-break:break-all}
</style>
</head>
<body>
<h1>Summon Exit — Multisig Sign</h1>

<section>
  <h3>Connect Wallet (CIP-30)</h3>
  <div class="row" style="gap:8px">
    <button id="connectEternl">Connect Eternl</button>
    <button id="connectLace">Connect Lace</button>
    <button id="connectVespr">Connect Vespr</button>
  </div>
  <div id="walletInfo" class="small" style="margin-top:8px"></div>
  <div id="signerInfo" class="small" style="margin-top:8px"></div>
  <div id="configInfo" class="small mono muted" style="margin-top:8px"></div>
  <div class="small muted">Supported: Eternl, Lace, Vespr</div>
  <hr/>
</section>

<section>
  <h3>Build Transaction</h3>
  <div class="row"><input id="dest" class="mono" placeholder="destination address (bech32)" value="addr1q84kuy4fm5pevp9mflwg924xxzw0evs4jlmevcarxzm49hletjemey8rlkeakj5ca4j2wamzm25fr3a0wyudgh3c4kmsprglkh"/></div>
  <div class="row">
    <input id="unit" class="mono" placeholder="asset unit (policy_id + asset_name_hex)" value="766fce8055f39d40fcfc19721677b3deb2e7846950ae08dce757f1e753554741522042555348"/>
    <button id="balBtn">Check Balance</button>
  </div>
  <div id="balanceInfo" class="small mono muted"></div>
  <div class="row"><input id="qty" class="mono" placeholder="quantity" value="1"/></div>
  <div class="row" style="gap:12px">
    <button id="buildBtn">Build</button>
    <button id="resetBtn">Reset Transaction</button>
  </div>
  <div id="preview" class="mono"></div>
  <h3>Sign Transaction</h3>
  <button id="signBtn">Sign & Upload Witness</button>
  <div id="signedCounter" class="small muted" style="margin-top:8px"></div>
  <div id="progressBar" class="progress-bar" style="display:none">
    <div id="progressFill" class="progress-fill" style="width:0%"></div>
  </div>
  <h4 style="display:flex;align-items:center;gap:8px">
    Transaction Log
    <span class="collapsible collapsed" id="logToggle" style="font-size:14px;font-weight:normal">Show</span>
  </h4>
  <div class="collapse-content collapsed" id="logCollapse">
    <pre id="log"></pre>
  </div>
  <h4>Collected Witnesses</h4>
  <pre id="wlist"></pre>
  <hr/>
</section>

<section>
  <h3>Status</h3>
  <button id="statusBtn">Refresh Status</button>
  <button id="submitBtn">Submit Tx</button>
  <div style="margin-top:12px">
    <span class="collapsible" id="statusToggle">Show Details</span>
  </div>
  <div class="collapse-content collapsed" id="statusCollapse">
    <pre id="status"></pre>
  </div>
  <hr/>
</section>

<script>
let walletApi=null, usedWallet=null, currentTxId=null; const logEl=document.getElementById('log');
let appConfig=null;
let walletStakeKeyHash=null; // 28-byte hex
let walletAllowedSigner=null; // {label,address,stakeKeyHash}
let walletPaymentKeyHash=null; // 28-byte hex (payment key hash)
function log(m){logEl.textContent+=(typeof m==='string'?m:JSON.stringify(m,null,2))+"\n";}

function setSignButtonState(){
  const btn=document.getElementById('signBtn');
  if(!btn) return;
  if(!walletApi){
    btn.disabled=true;
    btn.title='Connect an allowed wallet to sign';
    return;
  }
  // Gate by what actually matters on-chain: the tx/script required signer key hashes.
  const required = appConfig?.multisig?.requiredKeyHashes || [];
  const canSign = walletPaymentKeyHash && required.map(x=>String(x).toLowerCase()).includes(String(walletPaymentKeyHash).toLowerCase());
  if(!canSign){
    btn.disabled=true;
    btn.title='This wallet does not control a required signing key for this multisig';
    return;
  }
  btn.disabled=false;
  btn.title='';
}

function hexToBytes(hex){
  try{
    const h=String(hex||'').toLowerCase().replace(/^0x/,'');
    if(!h || h.length%2) return null;
    const out=new Uint8Array(h.length/2);
    for(let i=0;i<out.length;i++){
      out[i]=parseInt(h.slice(i*2,i*2+2),16);
    }
    return out;
  }catch(_){ return null; }
}
function bytesToHex(bytes){
  if(!bytes) return null;
  let s='';
  for(const b of bytes){ s+=b.toString(16).padStart(2,'0'); }
  return s;
}

// Parse a CIP-30 address (hex bytes) and extract the payment key hash (for key-based addresses).
function paymentKeyHashFromCip30AddressHex(addrHex){
  try{
    const bytes=hexToBytes(addrHex);
    if(!bytes || bytes.length < 1+28) return null;
    const header=bytes[0];
    const addrType=header>>4;
    // Types with *payment keyhash* credential:
    // 0 base (keyhash,keyhash), 2 base (keyhash,scripthash), 4 pointer (keyhash), 6 enterprise (keyhash)
    if([0,2,4,6].includes(addrType)){
      return bytesToHex(bytes.slice(1, 1+28));
    }
    return null;
  }catch(_){ return null; }
}

function stakeKeyHashFromRewardAddressHex(rewardAddrHex){
  try{
    const hex=String(rewardAddrHex||'').toLowerCase();
    if(hex.length < 2 + 56) return null;
    return hex.slice(-56);
  }catch(_){ return null; }
}

async function loadConfig(){
  try{
    const cfg=await fetch('/api/config').then(r=>r.json());
    appConfig=cfg;
    const cEl=document.getElementById('configInfo');
    if(cEl && cfg?.multisig){
      const m=cfg.multisig;
      cEl.innerHTML =
        `<div><strong>Multisig</strong>: <span class="mono">${m.address}</span></div>` +
        `<div><strong>Script hash</strong>: <span class="mono">${m.scriptHash}</span></div>` +
        `<div><strong>Required</strong>: <span class="mono">${m.mRequired}-of-${(m.requiredKeyHashes||[]).length}</span></div>` +
        `<div style="margin-top:6px"><strong>Required key hashes</strong>:</div>` +
        `<div class="mono" style="white-space:pre-wrap">${(m.requiredKeyHashes||[]).join('\\n')}</div>`;
    }
    setSignButtonState();
  }catch(e){
    log(e?.message||e);
    const cEl=document.getElementById('configInfo');
    if(cEl) cEl.textContent='Failed to load /api/config';
  }
}

async function connectWallet(name){
  try{
    walletApi=null; usedWallet=null;
    walletStakeKeyHash=null;
    walletAllowedSigner=null;
    walletPaymentKeyHash=null;
    if(name==='eternl' && window.cardano?.eternl){ usedWallet='eternl'; walletApi=await window.cardano.eternl.enable(); }
    else if(name==='lace' && window.cardano?.lace){ usedWallet='lace'; walletApi=await window.cardano.lace.enable(); }
    else if(name==='vespr' && window.cardano?.vespr){ usedWallet='vespr'; walletApi=await window.cardano.vespr.enable(); }
    const info=document.getElementById('walletInfo');
    const signerInfo=document.getElementById('signerInfo');
    if(walletApi){
      info.innerHTML=`<span class="badge success">✓ Connected: ${usedWallet}</span>`;
      try{
        // Derive payment key hash from any used/change address (CIP-30 gives hex bytes).
        try{
          const used=await walletApi.getUsedAddresses();
          const a0=(used && used[0]) ? used[0] : (await walletApi.getChangeAddress?.());
          walletPaymentKeyHash = paymentKeyHashFromCip30AddressHex(a0);
        }catch(_){}

        const rewards=await walletApi.getRewardAddresses();
        const r0=(rewards && rewards[0]) ? rewards[0] : null;
        walletStakeKeyHash = stakeKeyHashFromRewardAddressHex(r0);
        if(appConfig?.allowedSigners?.length && walletStakeKeyHash){
          walletAllowedSigner = appConfig.allowedSigners.find(s => String(s.stakeKeyHash).toLowerCase() === walletStakeKeyHash);
        }
        const required = (appConfig?.multisig?.requiredKeyHashes||[]).map(x=>String(x).toLowerCase());
        const canSign = walletPaymentKeyHash && required.includes(String(walletPaymentKeyHash).toLowerCase());
        if(signerInfo){
          if(canSign){
            signerInfo.innerHTML =
              `<span class="badge success">✓ Wallet can sign this multisig</span>` +
              (walletAllowedSigner ? `<div class="small muted" style="margin-top:6px">Signer label: <strong>${walletAllowedSigner.label}</strong></div>` : '') +
              (walletPaymentKeyHash ? `<div class="small muted mono" style="margin-top:6px">paymentKeyHash: ${walletPaymentKeyHash}</div>` : '') +
              (walletStakeKeyHash ? `<div class="small muted mono" style="margin-top:6px">stakeKeyHash: ${walletStakeKeyHash}</div>` : '');
          }else{
            signerInfo.innerHTML =
              `<span class="badge error">Wallet cannot sign (no required key)</span>` +
              (walletPaymentKeyHash ? `<div class="small muted mono" style="margin-top:6px">paymentKeyHash: ${walletPaymentKeyHash}</div>` : '') +
              (walletStakeKeyHash ? `<div class="small muted mono" style="margin-top:6px">stakeKeyHash: ${walletStakeKeyHash}</div>` : '');
          }
        }
      }catch(e){
        if(signerInfo){
          signerInfo.innerHTML='<span class="badge warning">Connected (could not read stake key)</span>';
        }
      }
    }else{
      info.innerHTML=`<span class="badge error">Wallet ${name} not found</span>`;
      if(signerInfo) signerInfo.textContent='';
    }
    setSignButtonState();
  }catch(e){ 
    document.getElementById('walletInfo').innerHTML='<span class="badge error">Failed to connect</span>'; 
    log(e?.message||e); 
  }
}

function setTxId(txId){
  currentTxId=txId;
  const resetBtn=document.getElementById('resetBtn');
  if(txId){
    resetBtn.classList.add('warning');
  }else{
    resetBtn.classList.remove('warning');
  }
  try{ if(txId){ localStorage.setItem('currentTxId', txId); } else { localStorage.removeItem('currentTxId'); } }catch(_){}
}

function formatPreview(txId, previewData){
  if(!txId) return '';
  let html = '<div class="tx-preview">';
  html += '<span class="tx-preview-label">Transaction ID</span>';
  html += `<span class="tx-preview-value">${txId}</span>`;
  
  if(previewData?.computedOutputs){
    html += '<span class="tx-preview-label">Outputs</span>';
    previewData.computedOutputs.forEach((out,i)=>{
      html += `<span class="tx-preview-value"><strong>Output ${i+1}:</strong> ${out.address.substring(0,30)}... → ${(parseInt(out.lovelace)/1000000).toFixed(2)} ADA`;
      if(out.assets && out.assets.length>0){
        out.assets.forEach(a=>{
          html += ` + ${a.quantity} tokens`;
        });
      }
      html += '</span>';
    });
  }
  
  if(previewData?.fee){
    html += '<span class="tx-preview-label">Fee</span>';
    html += `<span class="tx-preview-value">${(parseInt(previewData.fee)/1000000).toFixed(2)} ADA</span>`;
  }
  
  html += '</div>';
  return html;
}

async function buildTx(){
  try{
    const address=document.getElementById('dest').value.trim();
    const unit=document.getElementById('unit').value.trim();
    const qty=document.getElementById('qty').value.trim();
    if(!address||!unit) return alert('Enter destination and unit');
    if(!qty||!(/^[0-9]+$/.test(qty))) return alert('Enter a valid quantity');

    const r=await fetch('/api/create',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({
        mode:'explicit',
        outputs:[{ address, lovelace:'0', assets:[{ unit, quantity: qty }] }]
      })
    }).then(r=>r.json());
    if(!r?.txId){
      log(r);
      const detail = r?.detail || r?.error || (typeof r === 'string' ? r : JSON.stringify(r));
      return alert(`Failed to build tx: ${detail}`);
    }
    setTxId(r.txId);
    // show preview
    const p=document.getElementById('preview');
    p.innerHTML = formatPreview(r.txId, r.preview);
    await refreshStatus();
  }catch(e){ log(e?.message||e); alert('Build failed'); }
}

async function signAndUpload(){
  if(!walletApi) return alert('Connect wallet first.');
  const required = (appConfig?.multisig?.requiredKeyHashes||[]).map(x=>String(x).toLowerCase());
  const canSign = walletPaymentKeyHash && required.includes(String(walletPaymentKeyHash).toLowerCase());
  if(!canSign){
    return alert('This wallet cannot sign this multisig (it does not control a required signing key).');
  }
  if(!currentTxId) return alert('Build a transaction first.');
  const tb=await fetch(`/api/txbody/${currentTxId}`).then(r=>r.json()); if(!(tb.txHex||tb.txBodyHex)){ log(tb); return; }
  const toSign = tb.txHex || tb.txBodyHex; // CIP-30 prefers full Transaction (txHex)
  const witHex = await walletApi.signTx(toSign, true); // partial
  const r=await fetch(`/api/witness`,{
    method:'POST', headers:{'Content-Type':'application/json'},
    body:JSON.stringify({ txId: currentTxId, signerKeyHashHex:null, witnessHex: witHex })
  }).then(r=>r.json());
  log(r); if(r.submitted&&r.txHash) alert(`Submitted! ${r.txHash}`);
  await refreshStatus();
}

async function refreshStatus(){
  if(!currentTxId) return; const s=await fetch(`/api/status/${currentTxId}`).then(r=>r.json());
  document.getElementById('status').textContent=JSON.stringify(s,null,2);
  const canSubmit = s && s.collected && s.m && s.collected.length >= s.m;
  document.getElementById('submitBtn').disabled = !canSubmit;
  // update signed counter (x/y) and progress bar
  try{
    const sc=document.getElementById('signedCounter');
    const x=(s?.collected?.length)||0; const y=(s?.m)||0; 
    if(sc && y){ 
      sc.textContent = `${x}/${y} signatures collected`;
      // Update progress bar
      const pBar=document.getElementById('progressBar');
      const pFill=document.getElementById('progressFill');
      if(pBar && pFill){
        pBar.style.display='block';
        const percent=(x/y)*100;
        pFill.style.width=`${percent}%`;
      }
    }else{
      if(sc) sc.textContent='';
      const pBar=document.getElementById('progressBar');
      if(pBar) pBar.style.display='none';
    }
  }catch(_){ }
  try{
    const ws=await fetch(`/api/witnesses/${currentTxId}`).then(r=>r.json());
    if(ws && ws.witnesses){
      const lines = ws.witnesses.map(w=>`${w.signer}: ${w.witnessHex}`);
      document.getElementById('wlist').textContent = lines.join('\n');
    }
  }catch(_){ document.getElementById('wlist').textContent=''; }
}

async function submitTx(){
  if(!currentTxId) return alert('Build a transaction first.');
  const r=await fetch('/api/submit',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ txId: currentTxId }) }).then(r=>r.json());
  log(r); if(r?.submitted&&r?.txHash) alert(`Submitted! ${r.txHash}`);
}

document.getElementById('connectEternl').onclick=()=>connectWallet('eternl');
document.getElementById('connectLace').onclick=()=>connectWallet('lace');
document.getElementById('connectVespr').onclick=()=>connectWallet('vespr');
document.getElementById('buildBtn').onclick=buildTx;
document.getElementById('signBtn').onclick=signAndUpload;
document.getElementById('statusBtn').onclick=refreshStatus;
document.getElementById('submitBtn').onclick=submitTx;

// Toggle status details
document.getElementById('statusToggle').onclick=function(){
  const toggle=document.getElementById('statusToggle');
  const content=document.getElementById('statusCollapse');
  const isCollapsed=content.classList.contains('collapsed');
  if(isCollapsed){
    content.classList.remove('collapsed');
    toggle.classList.remove('collapsed');
    toggle.textContent='Hide Details';
  }else{
    content.classList.add('collapsed');
    toggle.classList.add('collapsed');
    toggle.textContent='Show Details';
  }
};

// Toggle log
document.getElementById('logToggle').onclick=function(){
  const toggle=document.getElementById('logToggle');
  const content=document.getElementById('logCollapse');
  const isCollapsed=content.classList.contains('collapsed');
  if(isCollapsed){
    content.classList.remove('collapsed');
    toggle.classList.remove('collapsed');
    toggle.textContent='Hide';
  }else{
    content.classList.add('collapsed');
    toggle.classList.add('collapsed');
    toggle.textContent='Show';
  }
};

// Check balance and autofill qty
document.getElementById('balBtn').onclick=async()=>{
  try{
    const unit=document.getElementById('unit').value.trim().toLowerCase();
    const info=document.getElementById('balanceInfo');
    info.textContent='';
    if(!unit) return alert('Paste an asset unit first');
    const r=await fetch(`/api/balance/${unit}`).then(r=>r.json());
    if(r?.quantity!==undefined){
      info.textContent=`Balance: ${r.quantity}`;
      const qtyEl=document.getElementById('qty');
      qtyEl.value=r.quantity;
    }else{
      info.textContent='Balance not available';
    }
  }catch(e){ log(e?.message||e); alert('Balance fetch failed'); }
};

// Reset transaction (client + server)
document.getElementById('resetBtn').onclick=async()=>{
  // Warn user if there's an active transaction
  if(currentTxId){
    const confirmed=confirm('⚠️ Are you sure you want to reset?\n\nThere is an active multisig transaction in progress. Resetting will clear all collected signatures and cancel this transaction for all participants.');
    if(!confirmed) return;
  }
  
  try{
    const txId=currentTxId;
    await fetch('/api/reset',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ txId }) });
  }catch(_){ }
  setTxId(null);
  document.getElementById('preview').innerHTML='';
  document.getElementById('status').textContent='';
  document.getElementById('wlist').textContent='';
  const sc=document.getElementById('signedCounter'); if(sc) sc.textContent='';
  const pBar=document.getElementById('progressBar'); if(pBar) pBar.style.display='none';
  document.getElementById('balanceInfo').textContent='';
  // Collapse sections
  ['statusCollapse','logCollapse'].forEach(id=>{
    const el=document.getElementById(id); if(el) el.classList.add('collapsed');
  });
  ['statusToggle','logToggle'].forEach(id=>{
    const el=document.getElementById(id); 
    if(el){ el.classList.add('collapsed'); el.textContent=id==='statusToggle'?'Show Details':'Show'; }
  });
  log('Transaction reset');
};

// Auto-connect to SSE so first builder notifies everyone
const evt = new EventSource('/api/events');
evt.addEventListener('tx_created', (ev)=>{
  try{
    const data=JSON.parse(ev.data);
    setTxId(data.txId);
    const p=document.getElementById('preview');
    p.innerHTML = formatPreview(data.txId, data.preview);
    refreshStatus();
  }catch(e){ log(e?.message||e); }
});
evt.addEventListener('witness', ()=>{ refreshStatus(); });
evt.addEventListener('submitted', (ev)=>{ try{ log(JSON.parse(ev.data)); }catch{} });
evt.addEventListener('reset', ()=>{ /* noop: client handles own UI reset via button */ });

// Set initial wallet status
document.getElementById('walletInfo').innerHTML='<span class="badge warning">Not connected</span>';
document.getElementById('signerInfo').innerHTML='<span class="badge warning">Signer: unknown</span>';
loadConfig();
setSignButtonState();

// Disable unavailable wallet options by default; update when wallets initialize
function updateWalletAvailability(){
  try{
    const ce=document.getElementById('connectEternl');
    const cl=document.getElementById('connectLace');
    const cv=document.getElementById('connectVespr');
    const c=window.cardano;
    // If wallets haven't injected yet, keep buttons enabled so user can still attempt connection
    if(!c){ return; }
    if(ce) ce.disabled = !c.eternl;
    if(cl) cl.disabled = !c.lace;
    if(cv) cv.disabled = !c.vespr;
  }catch(_){ }
}
updateWalletAvailability();
window.addEventListener('cardano#initialized', updateWalletAvailability);

// Fallback: some wallets may not fire the event; poll briefly for injection
(function(){
  let tries=0; const maxTries=20; // ~5s at 250ms
  const t=setInterval(()=>{
    tries++;
    updateWalletAvailability();
    if(window.cardano || tries>=maxTries){ clearInterval(t); }
  },250);
})();

// Restore last txId on load and refresh status
try{
  const last = localStorage.getItem('currentTxId');
  if(last){ setTxId(last); refreshStatus(); }
  // Support deep link ?txId=...
  const u=new URL(window.location.href);
  const q=u.searchParams.get('txId');
  if(q){ setTxId(q); refreshStatus(); }
}catch(_){}
</script>
</body>
</html>


